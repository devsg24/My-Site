<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Gesture Drawing</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: white;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            font-weight: 600;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .canvas-container {
            position: relative;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
        }

        #drawingCanvas {
            border: 3px solid #667eea;
            border-radius: 15px;
            cursor: crosshair;
            background: white;
        }

        #videoElement {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border: 2px solid #667eea;
            border-radius: 10px;
            object-fit: cover;
            opacity: 0.8;
            z-index: 10;
        }

        .status {
            margin-top: 15px;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            text-align: center;
            font-weight: 500;
        }

        .status.active {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid #4CAF50;
        }

        .instructions {
            max-width: 600px;
            margin: 20px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .instructions h3 {
            margin-bottom: 10px;
            color: #FFD700;
        }

        .instructions ul {
            list-style: none;
            padding-left: 0;
        }

        .instructions li {
            margin: 8px 0;
            padding-left: 20px;
            position: relative;
        }

        .instructions li::before {
            content: "✋";
            position: absolute;
            left: 0;
        }

        .color-palette {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            justify-content: center;
            flex-wrap: wrap;
        }

        .color-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 3px solid white;
            cursor: pointer;
            transition: transform 0.2s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .color-btn:hover {
            transform: scale(1.1);
        }

        .color-btn.active {
            border-color: #FFD700;
            transform: scale(1.15);
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            #drawingCanvas {
                width: 90vw;
                height: 50vh;
            }

            #videoElement {
                width: 120px;
                height: 90px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>✋ Hand Gesture Drawing</h1>
        <p>Draw in the air with your hands!</p>
    </div>

    <div class="controls">
        <button id="startBtn" class="btn">Start Camera</button>
        <button id="clearBtn" class="btn" disabled>Clear Canvas</button>
        <button id="saveBtn" class="btn" disabled>Save Drawing</button>
        <select id="brushSize" class="btn" disabled>
            <option value="2">Thin Brush</option>
            <option value="5" selected>Normal Brush</option>
            <option value="10">Thick Brush</option>
            <option value="20">Very Thick</option>
        </select>
    </div>

    <div class="color-palette">
        <div class="color-btn active" data-color="#000000" style="background-color: #000000;"></div>
        <div class="color-btn" data-color="#FF0000" style="background-color: #FF0000;"></div>
        <div class="color-btn" data-color="#00FF00" style="background-color: #00FF00;"></div>
        <div class="color-btn" data-color="#0000FF" style="background-color: #0000FF;"></div>
        <div class="color-btn" data-color="#FFFF00" style="background-color: #FFFF00;"></div>
        <div class="color-btn" data-color="#FF00FF" style="background-color: #FF00FF;"></div>
        <div class="color-btn" data-color="#00FFFF" style="background-color: #00FFFF;"></div>
        <div class="color-btn" data-color="#FFA500" style="background-color: #FFA500;"></div>
    </div>

    <div class="canvas-container">
        <canvas id="drawingCanvas" width="800" height="600"></canvas>
        <video id="videoElement" autoplay muted></video>
    </div>

    <div id="status" class="status">Camera not started</div>

    <div class="instructions">
        <h3>How to Use:</h3>
        <ul>
            <li>Click "Start Camera" to begin</li>
            <li>Hold up your index finger to draw</li>
            <li>Make a fist to stop drawing</li>
            <li>Move your hand to control the cursor</li>
            <li>Change colors and brush sizes with the controls</li>
        </ul>
    </div>

    <script>
        class HandGestureDrawing {
            constructor() {
                this.video = document.getElementById('videoElement');
                this.canvas = document.getElementById('drawingCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.status = document.getElementById('status');
                this.isDrawing = false;
                this.lastX = 0;
                this.lastY = 0;
                this.currentColor = '#000000';
                this.brushSize = 5;
                this.cameraActive = false;

                this.init();
            }

            init() {
                // Set up canvas
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                
                // Event listeners
                document.getElementById('startBtn').addEventListener('click', () => this.startCamera());
                document.getElementById('clearBtn').addEventListener('click', () => this.clearCanvas());
                document.getElementById('saveBtn').addEventListener('click', () => this.saveDrawing());
                document.getElementById('brushSize').addEventListener('change', (e) => {
                    this.brushSize = parseInt(e.target.value);
                });

                // Color palette
                document.querySelectorAll('.color-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelector('.color-btn.active').classList.remove('active');
                        e.target.classList.add('active');
                        this.currentColor = e.target.dataset.color;
                    });
                });

                // Mouse fallback for testing
                this.canvas.addEventListener('mousedown', (e) => this.startDrawing(e));
                this.canvas.addEventListener('mousemove', (e) => this.draw(e));
                this.canvas.addEventListener('mouseup', () => this.stopDrawing());
                this.canvas.addEventListener('mouseout', () => this.stopDrawing());

                this.updateStatus('Ready to start camera');
            }

            async startCamera() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { width: 640, height: 480 }
                    });
                    
                    this.video.srcObject = stream;
                    this.cameraActive = true;
                    
                    this.video.onloadedmetadata = () => {
                        this.startHandTracking();
                    };
                    
                    document.getElementById('startBtn').textContent = 'Camera Active';
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('clearBtn').disabled = false;
                    document.getElementById('saveBtn').disabled = false;
                    document.getElementById('brushSize').disabled = false;
                    
                    this.updateStatus('Camera active - Move your hand to draw!', true);
                    
                } catch (err) {
                    console.error('Error accessing camera:', err);
                    this.updateStatus('Camera access denied or not available');
                    this.enableMouseDrawing();
                }
            }

            startHandTracking() {
                // Simple hand tracking simulation
                // In a real implementation, you'd use MediaPipe or TensorFlow.js
                this.trackingInterval = setInterval(() => {
                    this.simulateHandTracking();
                }, 50);
            }

            simulateHandTracking() {
                // This is a simplified simulation
                // Real hand tracking would analyze video frames
                const rect = this.canvas.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                
                // Simulate hand movement (you can replace this with actual hand tracking)
                // For now, this creates a subtle animation effect
                const time = Date.now() * 0.001;
                const x = centerX + Math.sin(time) * 50;
                const y = centerY + Math.cos(time) * 50;
                
                // For demonstration, we'll draw when the simulated hand is in certain positions
                if (Math.random() > 0.7) { // Randomly "detect" drawing gesture
                    this.drawAt(x, y);
                }
            }

            enableMouseDrawing() {
                this.updateStatus('Using mouse mode - click and drag to draw', true);
                document.getElementById('clearBtn').disabled = false;
                document.getElementById('saveBtn').disabled = false;
                document.getElementById('brushSize').disabled = false;
            }

            startDrawing(e) {
                this.isDrawing = true;
                const rect = this.canvas.getBoundingClientRect();
                this.lastX = e.clientX - rect.left;
                this.lastY = e.clientY - rect.top;
            }

            draw(e) {
                if (!this.isDrawing) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;
                
                this.drawLine(this.lastX, this.lastY, currentX, currentY);
                
                this.lastX = currentX;
                this.lastY = currentY;
            }

            drawAt(x, y) {
                if (!this.isDrawing) {
                    this.isDrawing = true;
                    this.lastX = x;
                    this.lastY = y;
                    return;
                }
                
                this.drawLine(this.lastX, this.lastY, x, y);
                this.lastX = x;
                this.lastY = y;
            }

            drawLine(x1, y1, x2, y2) {
                this.ctx.globalCompositeOperation = 'source-over';
                this.ctx.strokeStyle = this.currentColor;
                this.ctx.lineWidth = this.brushSize;
                
                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);
                this.ctx.lineTo(x2, y2);
                this.ctx.stroke();
            }

            stopDrawing() {
                this.isDrawing = false;
            }

            clearCanvas() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }

            saveDrawing() {
                const link = document.createElement('a');
                link.download = 'hand-drawing-' + Date.now() + '.png';
                link.href = this.canvas.toDataURL();
                link.click();
            }

            updateStatus(message, active = false) {
                this.status.textContent = message;
                this.status.classList.toggle('active', active);
            }
        }

        // Initialize the app when page loads
        window.addEventListener('load', () => {
            new HandGestureDrawing();
        });

        // Add some visual feedback
        window.addEventListener('load', () => {
            // Create floating particles effect
            function createParticle() {
                const particle = document.createElement('div');
                particle.style.cssText = `
                    position: fixed;
                    width: 6px;
                    height: 6px;
                    background: rgba(255, 255, 255, 0.6);
                    border-radius: 50%;
                    pointer-events: none;
                    z-index: 1000;
                    animation: float 4s linear forwards;
                `;
                
                particle.style.left = Math.random() * window.innerWidth + 'px';
                particle.style.top = window.innerHeight + 'px';
                
                document.body.appendChild(particle);
                
                setTimeout(() => {
                    particle.remove();
                }, 4000);
            }

            // Add CSS for particle animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes float {
                    to {
                        transform: translateY(-${window.innerHeight + 100}px) rotate(360deg);
                        opacity: 0;
                    }
                }
            `;
            document.head.appendChild(style);

            // Create particles periodically
            setInterval(createParticle, 800);
        });
    </script>
</body>
</html>        indexTip[0] - thumbTip[0],
        indexTip[1] - thumbTip[1]
      );
      return distance < 40; // Adjust sensitivity here
    }

    async function detectHands() {
      const predictions = await model.estimateHands(video);
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (predictions.length > 0) {
        const landmarks = predictions[0].landmarks;
        const indexFinger = landmarks[8];

        // Draw fingertip for debug
        ctx.beginPath();
        ctx.arc(indexFinger[0], indexFinger[1], 5, 0, 2 * Math.PI);
        ctx.fillStyle = "red";
        ctx.fill();

        drawing = isPinching(landmarks);

        if (drawing && previousPosition) {
          ctx.beginPath();
          ctx.moveTo(previousPosition[0], previousPosition[1]);
          ctx.lineTo(indexFinger[0], indexFinger[1]);
          ctx.strokeStyle = "black";
          ctx.lineWidth = 3;
          ctx.stroke();
        }

        previousPosition = [indexFinger[0], indexFinger[1]];
      } else {
        previousPosition = null;
      }

      requestAnimationFrame(detectHands);
    }

    async function main() {
      await setupCamera();
      await loadModel();
      detectHands();
    }

    main();
  </script>
</body>
</html>
